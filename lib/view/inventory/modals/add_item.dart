// ignore_for_file: library_private_types_in_public_api, avoid_print, use_build_context_synchronously

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Import necessary backend components
import 'package:jcsd_flutter/backend/modules/inventory/inventory_data.dart';
import 'package:jcsd_flutter/backend/modules/inventory/inventory_providers.dart';
import 'package:jcsd_flutter/backend/modules/inventory/item_types/itemtypes_providers.dart';
import 'package:jcsd_flutter/backend/modules/suppliers/suppliers_state.dart';

// Assuming showCustomNotificationDialog is defined elsewhere and works
import 'package:jcsd_flutter/view/generic/dialogs/generic_dialog.dart';

class AddItemModal extends ConsumerStatefulWidget {
  const AddItemModal({super.key});

  @override
  ConsumerState<AddItemModal> createState() => _AddItemModalState();
}

class _AddItemModalState extends ConsumerState<AddItemModal> {
  bool _isSaving = false; // For button loading state
  final _formKey = GlobalKey<FormState>(); // Form key for validation

  // Controllers for input fields
  final TextEditingController _addItemName = TextEditingController();
  final TextEditingController _addItemDescription = TextEditingController();
  final TextEditingController _addItemPrice = TextEditingController();
  final TextEditingController _addItemQuantity = TextEditingController();

  // State for dropdown selections
  int? _selectedItemTypeID;
  int? _selectedSupplierID;

  @override
  void dispose() {
    _addItemName.dispose();
    _addItemDescription.dispose();
    _addItemPrice.dispose();
    _addItemQuantity.dispose();
    // No need to dispose _addItemType or _addItemSupplier if they were removed
    super.dispose();
  }

  /// Handles validation and submission of the new item.
  Future<void> _submitNewItem() async {
    // 1. Validate Form
    if (!_formKey.currentState!.validate()) {
       showCustomNotificationDialog(
          context: context,
          headerBar: "Input Error",
          messageText: "Please fix the errors in the form.");
       return;
    }

    // 2. Parse validated values (should not fail if validation passed)
    final int itemQuantity = int.parse(_addItemQuantity.text);
    final double itemPrice = double.parse(_addItemPrice.text);

    setState(() => _isSaving = true);

    // 3. Create the InventoryData object for the new item
    final newItem = InventoryData(
      itemID: 0, // ID is usually generated by the backend
      supplierID: _selectedSupplierID!, // Not null due to validator
      itemName: _addItemName.text.trim(),
      itemTypeID: _selectedItemTypeID!, // Not null due to validator
      itemDescription: _addItemDescription.text.trim(),
      itemQuantity: itemQuantity,
      itemPrice: itemPrice,
      isVisible: true, // New items are active by default
    );

    // 4. Call the addItem method on the notifier
    try {
      // Assuming adding to the active list context
      const bool isVisibleContext = true;
      await ref.read(InventoryNotifierProvider(isVisibleContext).notifier).addNewItem(newItem);

      Navigator.pop(context); // Close on success
      showCustomNotificationDialog(
         context: context, // Use the correct context
         headerBar: "Operation Success!",
         messageText: "Added new item successfully!");
      // Add Audit Logs here! Last nayan

    } catch (err) {
      print("Error adding item: $err");
      showCustomNotificationDialog(
         context: context, // Use the correct context
         headerBar: "Error",
         messageText: "Failed adding new item. ${err.toString()}");
    } finally {
      if (mounted) {
        setState(() => _isSaving = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;
    double containerWidth = screenWidth > 600 ? 700 : screenWidth * 0.95;

    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      insetPadding: EdgeInsets.symmetric(horizontal: screenWidth > 600 ? 50.0 : 16.0),
      child: SizedBox(
        width: containerWidth,
        child: Form( 
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min, 
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Container(
                width: double.infinity,
                padding: const EdgeInsets.symmetric(vertical: 10.0),
                decoration: const BoxDecoration(
                  color: Color(0xFF00AEEF),
                  borderRadius: BorderRadius.vertical(top: Radius.circular(10)),
                ),
                child: const Center(
                  child: Text('Add New Item', style: TextStyle(fontFamily: 'NunitoSans', fontWeight: FontWeight.bold, fontSize: 20, color: Colors.white)),
                ),
              ),

              // Builds the form, limpyo na
              _buildForm(), 

              // Action buttons here
              Padding(
                padding: const EdgeInsets.all(16.0), // Consistent padding
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    Expanded(
                      child: TextButton(
                        onPressed: _isSaving ? null : () => Navigator.pop(context),
                        style: TextButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 14.0),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(5), side: const BorderSide(color: Color(0xFF00AEEF))),
                        ),
                        child: const Text('Cancel', style: TextStyle(fontFamily: 'NunitoSans', fontWeight: FontWeight.bold, color: Color(0xFF00AEEF))),
                      ),
                    ),
                    const SizedBox(width: 10),
                    Expanded(
                      child: ElevatedButton(
                        onPressed: _isSaving ? null : _submitNewItem,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF00AEEF),
                          padding: const EdgeInsets.symmetric(vertical: 14.0),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(5)),
                        ),
                        child: _isSaving
                          ? const SizedBox(height: 20, width: 20, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white))
                          : const Text('Submit', style: TextStyle(fontFamily: 'NunitoSans', fontWeight: FontWeight.bold, color: Colors.white)),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  /// Builds the main form content.
  Widget _buildForm() {
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Left Column
            Expanded(
              flex: 1,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.start,
                children: [
                  _buildTextField(label: 'Item Name', hintText: 'Enter item name', controller: _addItemName, isRequired: true),
                  const SizedBox(height: 12),
                  _buildTextField(label: 'Item Description', hintText: 'Enter item description', controller: _addItemDescription, maxLines: 3, isRequired: true),
                  const SizedBox(height: 12),
                  _buildTextField(label: 'Initial Quantity', hintText: 'Enter starting quantity', controller: _addItemQuantity, keyboardType: TextInputType.number, isRequired: true, isNumeric: true, allowNegative: false),
                ],
              ),
            ),
            const SizedBox(width: 16),
            // Right Column
            Expanded(
              flex: 1,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.start,
                children: [
                  _buildItemTypeList(label: 'Item Type', hintText: 'Select item type'),
                  const SizedBox(height: 12),
                  _buildSuppliersList(label: 'Supplier', hintText: 'Select supplier'),
                  const SizedBox(height: 12),
                  _buildPriceField(),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Builds a reusable TextFormField.
  Widget _buildTextField({
    required String label,
    required String hintText,
    required TextEditingController controller,
    int maxLines = 1,
    TextInputType? keyboardType,
    bool isRequired = false,
    bool isNumeric = false, // Flag for numeric validation
    bool allowDecimal = false, // Flag for decimal validation
    bool allowNegative = true, // Flag for negative number validation
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(children: [ Text(label, style: const TextStyle(fontFamily: 'NunitoSans')), if (isRequired) const Text('*', style: TextStyle(color: Colors.red)) ]),
        const SizedBox(height: 5),
        TextFormField(
          controller: controller,
          maxLines: maxLines,
          keyboardType: keyboardType,
          inputFormatters: isNumeric && allowDecimal
              ? [FilteringTextInputFormatter.allow(RegExp(r'^\d*\.?\d{0,2}'))] // Decimal number formatter
              : isNumeric
                  ? [FilteringTextInputFormatter.digitsOnly] // Integer only formatter
                  : null,
          decoration: InputDecoration(
            hintText: hintText,
            border: const OutlineInputBorder(),
            contentPadding: const EdgeInsets.symmetric(vertical: 10.0, horizontal: 12.0),
            hintStyle: const TextStyle(fontFamily: 'Poppins', fontWeight: FontWeight.w300, fontSize: 12),
          ),
          validator: (value) {
            if (isRequired && (value == null || value.trim().isEmpty)) {
              return '$label is required';
            }
            if (isNumeric && value != null && value.isNotEmpty) {
              final number = num.tryParse(value);
              if (number == null) {
                return 'Invalid number format';
              }
              if (!allowNegative && number < 0) {
                return 'Cannot be negative';
              }
            }
            return null; // Valid
          },
          autovalidateMode: AutovalidateMode.onUserInteraction,
        ),
      ],
    );
  }

  /// Builds the dropdown for Item Type.
  Widget _buildItemTypeList({required String label, required String hintText}) {
    // Use the correct provider (assuming fetchActiveTypes is appropriate for adding new items)
    final itemTypesAsyncValue = ref.watch(fetchActiveTypes);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
         Row(children: [ Text(label), const Text('*', style: TextStyle(color: Colors.red)) ]),
         const SizedBox(height: 5),
         itemTypesAsyncValue.when(
            data: (typeList) => DropdownButtonFormField<int>(
              value: _selectedItemTypeID,
              hint: Text(hintText, style: const TextStyle(fontSize: 12, color: Colors.grey)),
              decoration: const InputDecoration(border: OutlineInputBorder(), contentPadding: EdgeInsets.symmetric(vertical: 10.0, horizontal: 12.0)),
              items: typeList.map((itemType) => DropdownMenuItem<int>(value: itemType.itemTypeID, child: Text(itemType.itemType, style: const TextStyle(fontSize: 12)))).toList(),
              onChanged: (int? selectedId) => setState(() => _selectedItemTypeID = selectedId),
              validator: (value) => value == null ? 'Item type is required' : null,
              autovalidateMode: AutovalidateMode.onUserInteraction,
            ),
            loading: () => const Center(child: SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2))),
            error: (error, stack) => Text('Error: ${error.toString()}', style: const TextStyle(color: Colors.red, fontSize: 12)),
         ),
      ],
    );
  }

  /// Hehe, this is a fucking annoying method na present, but it is what it is :P 
  Widget _buildSuppliersList({required String label, required String hintText}) {
    final suppliersAsyncValue = ref.watch(fetchAvailableSuppliers); 

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
         Row(children: [ Text(label), const Text('*', style: TextStyle(color: Colors.red)) ]),
         const SizedBox(height: 5),
         suppliersAsyncValue.when(
            data: (supplierList) => DropdownButtonFormField<int>(
              value: _selectedSupplierID,
              isExpanded: true,
              hint: Text(hintText, style: const TextStyle(fontSize: 12, color: Colors.grey)),
              decoration: const InputDecoration(border: OutlineInputBorder(), contentPadding: EdgeInsets.symmetric(vertical: 10.0, horizontal: 12.0)),
              items: supplierList.map((supplier) => DropdownMenuItem<int>(value: supplier.supplierID, child: Text(supplier.supplierName, overflow: TextOverflow.ellipsis, style: const TextStyle(fontSize: 12)))).toList(),
              onChanged: (int? selectedId) => setState(() => _selectedSupplierID = selectedId),
              validator: (value) => value == null ? 'Supplier is required' : null,
              autovalidateMode: AutovalidateMode.onUserInteraction,
            ),
            loading: () => const Center(child: SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2))),
            error: (error, stack) => Text('Error: ${error.toString()}', style: const TextStyle(color: Colors.red, fontSize: 12)),
         ),
      ],
    );
  }

  /// Builds the TextFormField for Price.
  Widget _buildPriceField() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
         const Row(children: [
          Text('Item Price'),  
          Text(
            '*', 
          style: TextStyle(
            color: Colors.red
            )
          )
        ]
      ),
         const SizedBox(height: 5),
         //Validator has been implemented to ensure na tama ang input
         TextFormField(
            controller: _addItemPrice,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            inputFormatters: [
              FilteringTextInputFormatter.allow(
                RegExp(
                  r'^\d*\.?\d{0,2}'
                )
              )
            ],
            decoration: const InputDecoration(
               hintText: 'Enter item price',
               prefixText: 'P ',
               border: OutlineInputBorder(),
               contentPadding: EdgeInsets.symmetric(
                vertical: 10.0, 
                horizontal: 12.0
              ),
               hintStyle: TextStyle(
                fontSize: 12
              ),
            ),
            validator: (value) {
               if (value == null || value.trim().isEmpty) return 'Price is required';
               final price = double.tryParse(value);
               if (price == null || price < 0) return 'Invalid positive price';
               return null;
            },
            autovalidateMode: AutovalidateMode.onUserInteraction,
         ),
      ],
    );
  }
}